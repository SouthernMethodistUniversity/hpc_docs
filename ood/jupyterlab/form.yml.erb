<%-
require 'open3'


# find user conda environments
class CustomEnvironments2

  @cache = ActiveSupport::Cache::FileStore.new("/users/#{User.new.name}/.cache/OpenOnDemand/", :expires_in => 1.minute)

  def self.LookForConda()
    begin
      # try to find a path for conda
      script = 'eval $(conda shell.bash hook); /usr/bin/which conda'
      o, status = Open3.capture2('/bin/bash -l', stdin_data: script)
      output = o.split("\n")
      open('/users/jlagrone/jupyterlab_debug.out', 'a+') { |f|
        f.puts "Which conda returns "
        f.puts output
      }
      if output.empty?
        # TODO: change to default path / module
        return output
      else
        return output[0]
      end
    end
  end

  def self.LookForMamba()
    begin
      # try to find a path for mamba
      script = 'eval $(mamba shell.bash hook); /usr/bin/which mamba'
      o, status = Open3.capture2('/bin/bash -l', stdin_data: script)
      output = o.split("\n")
      open('/users/jlagrone/jupyterlab_debug.out', 'a+') { |f|
        f.puts "Which mamba returns "
        f.puts output
      }
      if output.empty?
        # TODO: change to default path / module
        return output
      else
        return output[0]
      end
    end
  end

  def self.LookForMicromamba()
    begin
      # try to find a path for micromamba
      script = 'eval $(micromamba shell.bash hook); /usr/bin/which micromamba'
      o, status = Open3.capture2('/usr/bin/bash -l', stdin_data: script)
      output = o.split("\n")
      open('/users/jlagrone/jupyterlab_debug.out', 'a+') { |f|
        f.puts "Which micromamba returns "
        f.puts output
      }
      if output.empty?
        # TODO: change to default path / module
        return output
      else
        return output[0]
      end
    end
  end

  def self.CondaEnvs2()
    begin

      conda_provider = LookForMicromamba()
      if conda_provider.empty?
        conda_provider = LookForMamba()
      end
      if conda_provider.empty?
        conda_provider = LookForConda()
      end

      #TODO: default check
      if conda_provider.empty?
        conda_provider = '/users/jlagrone/.local/bin/micromamba'
      end

      open('/users/jlagrone/jupyterlab_debug.out', 'a+') { |f|
        f.puts "Conda Provider: "
        f.puts conda_provider
      }
      # get Conda environments from Conda info
      script = conda_provider.to_str + ' env list -q'
      o, status = Open3.capture2('/usr/bin/bash -l', stdin_data: script)
      output = o.split("\n")

      open('/users/jlagrone/jupyterlab_debug.out', 'a+') { |f|
        f.puts "Running: "
        f.puts script
        f.puts output
      }

      # check the output of Conda info for useable envs
      conda_env = []
      enabled_envs = []
      disabled_envs = []
      output.each do |env| 
        # skip envs in /hpc/applications and commented out lines
        if env =~ /^((?!hpc\/applications).)*$/ && env[0] != '#'
          # Conda info returns an optional name followed by a path
          # so split the current line into the name (possibly blank)
          # and the path to the env
          split_env = env.split
    
          # if the name is blank use the path as the name
          if split_env.count == 1
            split_env.push(split_env[0])
          end
          conda_env.push(split_env)
        end
      end
      #return
      return conda_env
    end
  end

  def self.JupyterLabEnvs2
    begin
       
      @JupyterLabEnvs2 = []

      # always include the default python/3 module
      python3_module = [ "python/3",    "python/3" ]
      
      # always include to option to define a custom env
      custom_env = [ "Custom Environment - only use what is specified below", "custom"   ]
      @JupyterLabEnvs2.push(python3_module)
      @JupyterLabEnvs2.push(custom_env)

      # check the output of Conda info for useable envs
      enabled_envs = []
      disabled_envs = []
      @CondaEnvsTest = @cache.fetch("#{User.new.name}/conda_envs", race_condition_ttl: 30.seconds) do
        self.CondaEnvs2()
      end
      @CondaEnvsTest.each do |env| 
        # now check if there is a jupyter-lab in the env
        # if it exists, add it to the enabled list
        # otherwise add it to the disabled list
        jupyter_path = env[1] + "/bin/jupyter-lab"
        if File.file?(jupyter_path)
          tmp_env = env
          tmp_env[0] = "(Conda Env) " + env[0]
          enabled_envs.push(tmp_env)
        else
          tmp_env = env
          tmp_env[0] = "(Install jupyterlab to use) " + env[0]
          tmp_env[1] = "No Jupyter Lab"
          disabled_envs.push(tmp_env)
        end
      end
      # add the found environments to the list
      # the disabled environments are listed last
      enabled_envs.each do |env|
        @JupyterLabEnvs2.push(env)
      end
      disabled_envs.each do |env|
        @JupyterLabEnvs2.push(env)
      end
      #return
      @JupyterLabEnvs2
    end
  end

  def self.JupyterNotebookEnvs2
    begin
       
      @JupyterNotebookEnvs2 = []

      # always include the default python/3 module
      python3_module = [ "python/3",    "python/3" ]
      
      # always include to option to define a custom env
      custom_env = [ "Custom Environment - only use what is specified below", "custom"   ]
      @JupyterNotebookEnvs2.push(python3_module)
      @JupyterNotebookEnvs2.push(custom_env)

      # check the output of Conda info for useable envs
      enabled_envs = []
      disabled_envs = []
      @CondaEnvsTest2 = @cache.fetch("#{User.new.name}/conda_envs") do
        self.CondaEnvs2()
      end
      @CondaEnvsTest2.each do |env|
        # now check if there is a jupyter-notebook in the env
        # if it exists, add it to the enabled list
        # otherwise add it to the disabled list
        jupyter_path = env[1] + "/bin/jupyter-notebook"
        if File.file?(jupyter_path)
          tmp_env = env
          tmp_env[0] = "(Conda Env) " + env[0]
          enabled_envs.push(tmp_env)
        else
          tmp_env = env
          tmp_env[0] = "(Install jupyter notebook to use) " + env[0]
          tmp_env[1] = "No Jupyter Lab"
          disabled_envs.push(tmp_env)
        end
      end
      # add the found environments to the list
      # the disabled environments are listed last
      enabled_envs.each do |env|
        @JupyterNotebookEnvs2.push(env)
      end
      disabled_envs.each do |env|
        @JupyterNotebookEnvs2.push(env)
      end
      #return
      @JupyterNotebookEnvs2
    end
  end
end


-%>

---
cluster: "m3cluster"
form:
  - auto_queues
  - python_version
  - environment
  - bc_num_hours
  - bc_num_slots
  - use_exclusive
  - bc_num_cores
  - bc_num_memory
# Define attribute values that aren't meant to be modified by the user within
# the Dashboard form
attributes:
  python_version:
    label: "Select Python Environment"
    widget: select
    help: |
      - *python/3* is the default Anaconda Python 3 installation on M2 in the module "python/3"
      - We've listed your *Conda* environments we found in standard locations. If the one you want to use is greyed out, it means that you need to install jupyterlab in that environment before it can be used
      - Environments using *venv*, *virtualenv*, and others will not be listed above and should be loaded below in the "Custom Environment" settings
      - Other environments can be specified by selecting "Custom Environment"
    options:
      <%- CustomEnvironments2.JupyterLabEnvs2.each do |q| -%>
        - [ "<%= q[0] %>", "<%= q[1] %>" ]
      <%- end -%>
  environment:
    widget: text_area
    label: "Custom environment settings"
    help: |
      - Load any addition enviroment settings
      - Use *source path/to/environment/bin/activate* to load *pip* virtual environments from *venv* or *virtualenv*
      - Use *module load module1 module2 module3* to load M2 modules
      - Use *export MY_VARIABLE=my_value* to export shell variables
      - **NOTE:**  *jupyter-lab* must be available in your environment, if we can't find it we will load the version in the module "python/3" which may conflict with the settings you provided

  bc_num_hours:
    id: bc_num_hours
    label: Time (Hours)
    help: |
      - Number of hours to allocate
      - Exceeding walltime time will automaticaly stop this job.
    cacheable: true
    widget: number_field
    max: 24
    min: 1
    step: 1
    value: 1
  bc_num_slots:
    id: num_nodes
    label: Number of nodes
    help: Number of compute nodes 
    cacheable: true
    widget: number_field
    max: 81
    min: 1
    step: 1
    value: 1
  use_exclusive:
    label: "Enable exclusive use"
    id: enable_exclusive
    widget: check_box
    help: |
        Automically request all available resources on each node (CPU cores, memory, GPUs, etc.)

        **If your job does not require all of the available resources, this may result in significantly longer wait times**
  bc_num_cores:
    id: num_cpus
    label: "Cores per node"
    help: Number of CPU threads
    cacheable: true
    widget: number_field
    max: 36
    min: 1
    value: 1
  bc_num_memory:
    id: num_mem
    label: "Memory"
    help: "Please select the amount of memory (in GB) you need for your job."
    widget: number_field
    max: 250
    min: 1
    step: 1
    value: 6
