<%-
require 'open3'

# find user conda environments
class CustomEnvironments

  @cache = ActiveSupport::Cache::FileStore.new("/users/#{User.new.name}/.cache/OpenOnDemand/", :expires_in => 1.minute)

  def self.LookForConda()
    begin
      # try to find a path for conda
      # conda is usually a shell function, so it's not easily checked
      # look for CONDA_EXE environment variable
      script = "eval $(conda shell.bash hook);  /usr/bin/env | /usr/bin/grep -oP 'CONDA_EXE=\\K.+'"
      o, status = Open3.capture2('/bin/bash -l', stdin_data: script)
      output = o.split("\n")
      if output.empty?
        output
      else
        return output[0]
      end
    end
  end

  def self.LookForMamba()
    begin
      # try to find a path for mamba
      script = 'eval $(mamba shell.bash hook); /usr/bin/which mamba'
      o, status = Open3.capture2('/bin/bash -l', stdin_data: script)
      output = o.split("\n")
      if output.empty?
        return output
      else
        return output[0]
      end
    end
  end

  def self.LookForMicromamba()
    begin
      # try to find a path for micromamba
      script = 'eval $(micromamba shell.bash hook); /usr/bin/which micromamba'
      o, status = Open3.capture2('/usr/bin/bash -l', stdin_data: script)
      output = o.split("\n")
      if output.empty?
        return output
      else
        return output[0]
      end
    end
  end

  def self.GetCondaProviders()
    begin

      @FoundCondaProviders = []

      # system defaults in conda module
      val = ["Conda", "/hpc/m3/apps/conda/bin/conda"]
      @FoundCondaProviders.push(val)
      val = ["Mamba", "/hpc/m3/apps/conda/bin/mamba"]
      @FoundCondaProviders.push(val)
      
      temp = LookForMamba()
      if !(temp.empty?)
        val = ["Mamba", temp]
        @FoundCondaProviders.push(val)
      end

      temp = LookForMicromamba()
      if !(temp.empty?)
        val = ["Micromamba", temp]
        @FoundCondaProviders.push(val)
      end

      temp = LookForConda()
      if !(temp.empty?)
        val = ["Conda", temp]
        @FoundCondaProviders.push(val)
      end
 
      return @FoundCondaProviders
    end
  end

  def self.CondaProviders
    begin
      @CondaProviders = @cache.fetch("#{User.new.name}/conda_providers", race_condition_ttl: 30.seconds) do
        self.GetCondaProviders()
      end
      @CondaProviders
    end
  end

  def self.GetCondaEnvs(conda_command)
    begin

       # get Conda environments from Conda info
      script = conda_command + ' info -e'
      o, status = Open3.capture2('/usr/bin/bash -l', stdin_data: script)
      output = o.split("\n")
      conda_env = []
    
      # parse the output
      output.each do |env|
        # skip commented out lines
        if env[0] != '#'
          # Conda info returns an optional name followed by a path
          # so split the current line into the name (possibly blank)
          # and the path to the env
          split_env = env.split
    
          # if the name is blank insert a blank into the array
          if split_env.count == 1
            split_env = ["", split_env[0]]
          end
          
          # append the conda command
          split_env.push("Conda Env")
          split_env.push(conda_command)

          conda_env.push(split_env)
        end
      end

      return conda_env
    end
  end    

  def self.GetMambaEnvs(mamba_command)
    begin

       # get Conda environments from Conda info
      script = mamba_command + ' env list -q'
      o, status = Open3.capture2('/usr/bin/bash -l', stdin_data: script)
      output = o.split("\n")
      mamba_env = []

      # parse the output
      output.each do |env|
        # skip commented out lines
        if env[0] != '#'
          # Mamba info returns an optional name followed by a path
          # so split the current line into the name (possibly blank)
          # and the path to the env
          split_env = env.split

          # if the name is blank insert a blank into the array
          if split_env.count == 1
            split_env = ["", split_env[0]]
          end

          # append the conda command
          split_env.push("Mamba Env")
          split_env.push(mamba_command)

          mamba_env.push(split_env)
        end
      end

      return mamba_env
    end
  end

  def self.GetMicromambaEnvs(micromamba_command)
    begin

       # get Conda environments from Conda info
      script = micromamba_command + ' env list -q'
      o, status = Open3.capture2('/usr/bin/bash -l', stdin_data: script)
      output = o.split("\n")
      micromamba_env = []

      # parse the output
      # first 2 lines are headers
      output.shift
      output.shift

      output.each do |env|
        # skip commented out lines
        if env[0] != '#'
          # Micromamba info returns an optional name, optional activation, followed by a path
          # so split the current line into the name (possibly blank)
          # and the path to the env
          split_env = env.split

          # remove * for activated if present
          if split_env[0] == '*'
            env_split.shift
          end
          if split_env[1] == '*'
            env_split.delete_at(1)
          end

          # if the name is blank insert a blank into the array
          if split_env.count == 1
            split_env = ["", split_env[0]]
          end

          # append the conda command
          split_env.push("Micromamba Env")
          split_env.push(micromamba_command)
           
          micromamba_env.push(split_env)
        end
      end

      return micromamba_env
    end
  end    

  def self.UniqueEnvs()
    begin
   
      envs = []
      
      # get all the environments
      self.CondaProviders.each do |provider|
        if provider[0] == "Conda"
          temp = self.GetCondaEnvs(provider[1])
          temp.each do |val|
            envs.push(val)
          end
        elsif provider[0] == "Mamba"
          temp = self.GetMambaEnvs(provider[1])
          temp.each do |val|
            envs.push(val)
          end
        elsif provider[0] == "Micromamba"
          temp = self.GetMicromambaEnvs(provider[1])
          temp.each do |val|
            envs.push(val)
          end
        end
      end

      # remove duplicates. Prefer version with name if it exists
      i = 0
      while i < envs.count() do
        j = i + 1
        while j < envs.count() do
          if (envs[i][1] == envs[j][1])
            # if one has a name, keep that one
            if envs[i][0].empty? && !(envs[j][0].empty?)
              envs[i][0] = envs[j][0]
              envs[i][1] = envs[j][1]
              envs[i][2] = envs[j][2]
              envs[i][3] = envs[j][3]
            end
            envs.delete_at(j)
          else
            j += 1
          end
        end
        i += 1
      end
      return envs
    end
  end


  def self.CondaEnvs()
    begin

      conda_env = self.UniqueEnvs()
      return conda_env
    end
  end

  def self.JupyterLabEnvs
    begin
       
      @JupyterLabEnvs = []

      # always include the option to build
      build_new = [ "Build New Environment", "new", "Default Env Type", "Default Conda Path" ]
      
      # always include to option to define a custom env
      custom_env = [ "Custom Environment - only use what is specified below", "custom", "user provided", "user provided"   ]
      @JupyterLabEnvs.push(build_new)
      @JupyterLabEnvs.push(custom_env)

      # check the output of Conda info for useable envs
      enabled_envs = []
      disabled_envs = []
      @CondaEnvsTest = @cache.fetch("#{User.new.name}/conda_envs", race_condition_ttl: 30.seconds) do
        self.CondaEnvs()
      end
      @CondaEnvsTest.each do |env| 
        # now check if there is a jupyter-lab in the env
        # if it exists, add it to the enabled list
        # otherwise add it to the disabled list
        jupyter_path = env[1] + "/bin/jupyter-lab"
        if File.file?(jupyter_path)
          tmp_env = env
          tmp_env[0] = "(" + env[2] + ") " + env[0]
          enabled_envs.push(tmp_env)
        else
          tmp_env = env
          tmp_env[0] = "(" + env[2] + " -- Install jupyterlab to use) " + env[0]
          tmp_env[1] = "No Jupyter Lab"
          disabled_envs.push(tmp_env)
        end
      end
      # add the found environments to the list
      # the disabled environments are listed last
      enabled_envs.each do |env|
        @JupyterLabEnvs.push(env)
      end
      disabled_envs.each do |env|
        @JupyterLabEnvs.push(env)
      end
      #return
      @JupyterLabEnvs
    end
  end

end

# check queues
class CheckQueues
 
  @cache = ActiveSupport::Cache::FileStore.new("/users/#{User.new.name}/.cache/OpenOnDemand/", :expires_in => 1.minute)

  def self.GetQueues()
    begin
      # get list of queues from sinfo
      script = "/hpc/sys/apps/slurm/current/bin/sinfo --hide -ho '%R %l %c %m %G'"
      o, status = Open3.capture2e(script)
      tmp_output = o.split("\n")

      output = []
      tmp_output.each do |q|
        params = q.gsub(/\s+/m, ' ').strip.split(" ")
        
        # convert time to hours
        hours = 0
        tmp = params[1].split("-")
        if tmp.count == 2
          hours = hours + 24*tmp[0].to_i
          hours = hours + tmp[1].split(":")[0].to_i
        else
          hours = hours + tmp[0].split(":")[0].to_i
        end
        params[1] = hours
        
        # convert memory to GB (implicit floor division)
        params[3] = params[3].to_i / 1024

        # get number of gpus
        if params[4] == "(null)"
          params[4] = 0
        else
          params[4] = params[4].split(":")[-1]
        end

        # if HTC, set cores to 1
        if params[0] == "htc"
          params[2] = 1
        end

        # only keep queues with time limits <= 24 hours
        # or highmem
        if (hours < 25 || params[0] == "highmem")
          # set the time limit to 12 hours or max queue time
          params[1] = [params[1].to_i, 12].min
          output.push(params) 
        end
      end
      return output
    end
  end
  
  def self.Queues
    begin
      @Queues = @cache.fetch("#{User.new.name}/queues", race_condition_ttl: 30.seconds) do
        self.GetQueues()
      end
      return @Queues
    end
  end
end

-%>

---
cluster: "m3cluster"
form:
  - custom_queues
  - python_version
  - build_environment
  - environment_name
  - conda_command
  - conda_type
  - environment
  - bc_num_hours
  - notebook_timeout
  - bc_num_cores
  - bc_num_memory
  - bc_num_gpus
# Define attribute values that aren't meant to be modified by the user within
# the Dashboard form
attributes:
  custom_queues:
    label: "Partition"
    widget: select
    help: |
      Please select the [SLURM partition] to submit the job to.
      [SLURM partition]: https://southernmethodistuniversity.github.io/hpc_docs/about/queues.html#m3-queues
    options:
    <%- CheckQueues.Queues.each do |q| -%>
      - ["<%= q[0] %>", "<%= q[0] %>",
        data-max-bc-num-hours: "<%= q[1] %>",
        data-max-bc-num-cores: "<%= q[2] %>",
        data-max-bc-num-memory: "<%= q[3] %>",
        data-set-bc-num-gpus: "<%= q[4] %>",
        <%- if q[4].to_i == 0 -%>
        data-hide-bc-num-gpus: true,
        <%- else -%>
        data-show-bc-num-gpus: true,
        <%- end -%>
        ]
    <%- end -%>
  python_version:
    label: "Select Python Environment"
    widget: select
    help: |
      - We've listed your *Conda* environments we found in standard locations. If the one you want to use is greyed out, it means that you need to install jupyterlab in that environment before it can be used
      - Environments using *venv*, *virtualenv*, and others will not be listed above and should be loaded below in the "Custom Environment" settings
      - Other environments can be specified by selecting "Custom Environment"
    options:
      <%- CustomEnvironments.JupyterLabEnvs.each do |q| -%>
        - [ '<%= q[0] %>', '<%= q[1] %>',
            data-set-conda-command: '<%= q[3] %>',
            data-set-conda-type: '<%= q[2] %>',
            <%- if q[1] != "new" -%>
            data-hide-build-environment: true,
            data-hide-environment-name: true
            <%- end -%>
          ]
      <%- end -%>
  build_environment:
    label: Select a base environment to build
    widget: select
    value: "1"
    help: |
      Build a new Conda environment. These are simple base environments to help you
      get started, but you will likely need to install additional packages yourself.

      - data science: Common data science tools.
      - bioinformatics: Tools for bioinformatics workflows.
      - sklearn: Machine learning with scikit-learn.
      - R: Create an R environment with some base packages. 

      See our documentation on [Conda environments] for more information.
      The specific environment files for each of the found under [example environments]
      [Conda environments]: https://southernmethodistuniversity.github.io/hpc_docs/examples/conda/README
      [example environments]: https://southernmethodistuniversity.github.io/hpc_docs/examples/conda/README.html#creating-virtual-environments-from-environment-yml-file
    options:  
    - ["data science", "/hpc/m3/hpc_docs/docs/examples/conda/datascience.yml"]
    - ["bioinformatics", "/hpc/m3/hpc_docs/docs/examples/conda/bioinformatics.yml"]
    - ["sklearn", "/hpc/m3/hpc_docs/docs/examples/conda/sklearn.yml"]
    - ["R", "/hpc/m3/hpc_docs/docs/examples/conda/r.yml"]
  environment_name:
    label: Specify a name your you Conda environment
    help: |
      - If the environment name already exists, the job will fail
  conda_command:
    widget: "hidden_field"
  conda_type:
    widget: "hidden_field"
  environment:
    widget: text_area
    label: "Custom environment settings"
    help: |
      - Load any addition enviroment settings
      - Use *source path/to/environment/bin/activate* to load *pip* virtual environments from *venv* or *virtualenv*
      - Use *module load module1 module2 module3* to load modules
      - Use *export MY_VARIABLE=my_value* to export shell variables
      - **NOTE:**  *jupyter-lab* must be available in your environment.

  bc_num_hours:
    label: Time (Hours)
    help: |
      - Number of hours to allocate
      - Exceeding walltime time will automaticaly stop this job.
    cacheable: true
    widget: number_field
    max: 12
    min: 1
    step: 1
    value: 1
  notebook_timeout:
    widget: number_field
    label: Timeout (minutes)
    help: |
      - Time in minutes before a job is cancelled for being idle
    max: 60
    min: 15
    step: 1
    value: 30
  bc_num_cores:
    label: "Cores per node"
    help: Number of CPU threads
    cacheable: true
    widget: number_field
    max: 128
    min: 1
    value: 1
  bc_num_memory:
    label: "Memory"
    help: "Please select the amount of memory (in GB) you need for your job."
    widget: number_field
    max: 500
    min: 1
    step: 1
    value: 4
  bc_num_gpus:
    label: "Number of GPUs"
    help: "Please select the number of GPUs for your job"
    widget: number_field
    max: 8
    min: 0
    step: 0
    value: 1
